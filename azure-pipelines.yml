trigger:
  branches:
    include:
    - main
    - development

variables:
  # Pipeline variables
  vmImageName: 'ubuntu-latest'
  terraformVersion: '1.5.7'
  pythonVersion: '3.10'
  tfStateBlobContainerName: 'tfstate'
  tfStateKey: 'taskapi.tfstate'
  
  # Variable groups (configured in Azure DevOps)
  # - group: terraform-secrets  # Contains TF_VAR_* variables for Terraform

stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: BuildJob
    displayName: 'Build and Test'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: UsePythonVersion@0
      inputs:
        versionSpec: '$(pythonVersion)'
        addToPath: true
      displayName: 'Use Python $(pythonVersion)'

    - script: |
        python -m pip install --upgrade pip
        pip install flake8 pytest
        pip install -r app/requirements.txt
      displayName: 'Install dependencies'

    - script: |
        flake8 app --count --select=E9,F63,F7,F82 --show-source --statistics
      displayName: 'Run lint tests'

    - script: |
        pytest
      displayName: 'Run unit tests'
      
    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)/app'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/app.zip'
        replaceExistingArchive: true
      displayName: 'Archive FastAPI app'
      
    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)/ProcessTask'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/function.zip'
        replaceExistingArchive: true
      displayName: 'Archive Azure Function'
      
    - task: CopyFiles@2
      inputs:
        SourceFolder: '$(System.DefaultWorkingDirectory)/terraform'
        Contents: '**'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/terraform'
      displayName: 'Copy Terraform files'
      
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'drop'
        publishLocation: 'Container'
      displayName: 'Publish build artifacts'

- stage: InfrastructureDev
  displayName: 'Deploy Infrastructure (Dev)'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/development'))
  variables:
    environment: 'dev'
  jobs:
  - job: TerraformDeploy
    displayName: 'Deploy with Terraform'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: DownloadBuildArtifacts@1
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'drop'
        downloadPath: '$(System.ArtifactsDirectory)'
      
    - task: AzureCLI@2
      inputs:
        azureSubscription: 'Azure-Service-Connection'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Create storage account for Terraform state if it doesn't exist
          STORAGE_ACCOUNT_NAME="taskapitfstate$(environment)"
          RESOURCE_GROUP_NAME="terraform-state-rg"
          
          # Check if resource group exists, create if not
          if ! az group show --name $RESOURCE_GROUP_NAME &>/dev/null; then
            echo "Creating resource group $RESOURCE_GROUP_NAME"
            az group create --name $RESOURCE_GROUP_NAME --location eastus
          fi
          
          # Check if storage account exists, create if not
          if ! az storage account show --name $STORAGE_ACCOUNT_NAME --resource-group $RESOURCE_GROUP_NAME &>/dev/null; then
            echo "Creating
# Check if storage account exists, create if not
          if ! az storage account show --name $STORAGE_ACCOUNT_NAME --resource-group $RESOURCE_GROUP_NAME &>/dev/null; then
            echo "Creating storage account $STORAGE_ACCOUNT_NAME"
            az storage account create --name $STORAGE_ACCOUNT_NAME --resource-group $RESOURCE_GROUP_NAME --sku Standard_LRS --encryption-services blob
          fi
          
          # Create blob container if it doesn't exist
          if ! az storage container show --name $(tfStateBlobContainerName) --account-name $STORAGE_ACCOUNT_NAME &>/dev/null; then
            echo "Creating storage container $(tfStateBlobContainerName)"
            az storage container create --name $(tfStateBlobContainerName) --account-name $STORAGE_ACCOUNT_NAME
          fi
          
          # Get storage account key
          STORAGE_ACCOUNT_KEY=$(az storage account keys list --resource-group $RESOURCE_GROUP_NAME --account-name $STORAGE_ACCOUNT_NAME --query '[0].value' -o tsv)
          
          # Set environment variables for Terraform
          echo "##vso[task.setvariable variable=ARM_ACCESS_KEY]$STORAGE_ACCOUNT_KEY"
      displayName: 'Prepare Terraform backend'
    
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: $(terraformVersion)
      displayName: 'Install Terraform'
      
    - task: TerraformTaskV3@3
      inputs:
        provider: 'azurerm'
        command: 'init'
        workingDirectory: '$(System.ArtifactsDirectory)/drop/terraform'
        backendServiceArm: 'Azure-Service-Connection'
        backendAzureRmResourceGroupName: 'terraform-state-rg'
        backendAzureRmStorageAccountName: 'taskapitfstate$(environment)'
        backendAzureRmContainerName: $(tfStateBlobContainerName)
        backendAzureRmKey: '$(environment).$(tfStateKey)'
      displayName: 'Terraform init'
      
    - task: TerraformTaskV3@3
      inputs:
        provider: 'azurerm'
        command: 'plan'
        workingDirectory: '$(System.ArtifactsDirectory)/drop/terraform'
        environmentServiceNameAzureRM: 'Azure-Service-Connection'
        commandOptions: '-var="prefix=taskapi-$(environment)" -out=tfplan'
      displayName: 'Terraform plan'
      
    - task: TerraformTaskV3@3
      inputs:
        provider: 'azurerm'
        command: 'apply'
        workingDirectory: '$(System.ArtifactsDirectory)/drop/terraform'
        environmentServiceNameAzureRM: 'Azure-Service-Connection'
        commandOptions: 'tfplan'
      displayName: 'Terraform apply'

- stage: DeployDev
  displayName: 'Deploy Applications (Dev)'
  dependsOn: InfrastructureDev
  condition: succeeded()
  variables:
    environment: 'dev'
  jobs:
  - job: DeployApps
    displayName: 'Deploy App and Function'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: DownloadBuildArtifacts@1
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'drop'
        downloadPath: '$(System.ArtifactsDirectory)'
        
    - task: AzureCLI@2
      inputs:
        azureSubscription: 'Azure-Service-Connection'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Get outputs from Terraform
          cd $(System.ArtifactsDirectory)/drop/terraform
          RESOURCE_GROUP=$(terraform output -raw resource_group_name)
          API_NAME=$(terraform output -raw api_url | cut -d'/' -f3 | cut -d'.' -f1)
          FUNCTION_NAME=$(terraform output -raw function_url | cut -d'/' -f3 | cut -d'.' -f1)
          
          echo "Resource Group: $RESOURCE_GROUP"
          echo "API App Name: $API_NAME"
          echo "Function App Name: $FUNCTION_NAME"
          
          # Deploy FastAPI app
          echo "Deploying FastAPI app to $API_NAME"
          az webapp deployment source config-zip --resource-group $RESOURCE_GROUP --name $API_NAME --src $(System.ArtifactsDirectory)/drop/app.zip
          
          # Deploy Azure Function
          echo "Deploying Azure Function to $FUNCTION_NAME"
          az functionapp deployment source config-zip --resource-group $RESOURCE_GROUP --name $FUNCTION_NAME --src $(System.ArtifactsDirectory)/drop/function.zip
          
          # Get function key and update the API app setting
          echo "Getting function key and updating API app settings"
          FUNCTION_KEY=$(az functionapp keys list --resource-group $RESOURCE_GROUP --name $FUNCTION_NAME --query "functionKeys.default" -o tsv)
          az webapp config appsettings set --resource-group $RESOURCE_GROUP --name $API_NAME --settings FUNCTION_KEY=$FUNCTION_KEY
      displayName: 'Deploy applications'

- stage: InfrastructureProd
  displayName: 'Deploy Infrastructure (Prod)'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  variables:
    environment: 'prod'
  jobs:
  - deployment: ApprovalInfra
    displayName: 'Approval for Production Infrastructure'
    environment: Production
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadBuildArtifacts@1
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'drop'
              downloadPath: '$(System.ArtifactsDirectory)'
            
          - task: AzureCLI@2
            inputs:
              azureSubscription: 'Azure-Service-Connection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Create storage account for Terraform state if it doesn't exist
                STORAGE_ACCOUNT_NAME="taskapitfstate$(environment)"
                RESOURCE_GROUP_NAME="terraform-state-rg"
                
                # Check if resource group exists, create if not
                if ! az group show --name $RESOURCE_GROUP_NAME &>/dev/null; then
                  echo "Creating resource group $RESOURCE_GROUP_NAME"
                  az group create --name $RESOURCE_GROUP_NAME --location eastus
                fi
                
                # Check if storage account exists, create if not
                if ! az storage account show --name $STORAGE_ACCOUNT_NAME --resource-group $RESOURCE_GROUP_NAME &>/dev/null; then
                  echo "Creating storage account $STORAGE_ACCOUNT_NAME"
                  az storage account create --name $STORAGE_ACCOUNT_NAME --resource-group $RESOURCE_GROUP_NAME --sku Standard_LRS --encryption-services blob
                fi
                
                # Create blob container if it doesn't exist
                if ! az storage container show --name $(tfStateBlobContainerName) --account-name $STORAGE_ACCOUNT_NAME &>/dev/null; then
                  echo "Creating storage container $(tfStateBlobContainerName)"
                  az storage container create --name $(tfStateBlobContainerName) --account-name $STORAGE_ACCOUNT_NAME
                fi
                
                # Get storage account key
                STORAGE_ACCOUNT_KEY=$(az storage account keys list --resource-group $RESOURCE_GROUP_NAME --account-name $STORAGE_ACCOUNT_NAME --query '[0].value' -o tsv)
                
                # Set environment variables for Terraform
                echo "##vso[task.setvariable variable=ARM_ACCESS_KEY]$STORAGE_ACCOUNT_KEY"
            displayName: 'Prepare Terraform backend'
          
          - task: TerraformInstaller@0
            inputs:
              terraformVersion: $(terraformVersion)
            displayName: 'Install Terraform'
            
          - task: TerraformTaskV3@3
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(System.ArtifactsDirectory)/drop/terraform'
              backendServiceArm: 'Azure-Service-Connection'
              backendAzureRmResourceGroupName: 'terraform-state-rg'
              backendAzureRmStorageAccountName: 'taskapitfstate$(environment)'
              backendAzureRmContainerName: $(tfStateBlobContainerName)
              backendAzureRmKey: '$(environment).$(tfStateKey)'
            displayName: 'Terraform init'
            
          - task: TerraformTaskV3@3
            inputs:
              provider: 'azurerm'
              command: 'plan'
              workingDirectory: '$(System.ArtifactsDirectory)/drop/terraform'
              environmentServiceNameAzureRM: 'Azure-Service-Connection'
              commandOptions: '-var="prefix=taskapi-$(environment)" -out=tfplan'
            displayName: 'Terraform plan'
            
          - task: TerraformTaskV3@3
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(System.ArtifactsDirectory)/drop/terraform'
              environmentServiceNameAzureRM: 'Azure-Service-Connection'
              commandOptions: 'tfplan'
            displayName: 'Terraform apply'

- stage: DeployProd
  displayName: 'Deploy Applications (Prod)'
  dependsOn: InfrastructureProd
  condition: succeeded()
  variables:
    environment: 'prod'
  jobs:
  - deployment: ApprovalDeploy
    displayName: 'Approval for Production Deployment'
    environment: Production
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadBuildArtifacts@1
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'drop'
              downloadPath: '$(System.ArtifactsDirectory)'
              
          - task: AzureCLI@2
            inputs:
              azureSubscription: 'Azure-Service-Connection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Get outputs from Terraform
                cd $(System.ArtifactsDirectory)/drop/terraform
                RESOURCE_GROUP=$(terraform output -raw resource_group_name)
                API_NAME=$(terraform output -raw api_url | cut -d'/' -f3 | cut -d'.' -f1)
                FUNCTION_NAME=$(terraform output -raw function_url | cut -d'/' -f3 | cut -d'.' -f1)
                
                echo "Resource Group: $RESOURCE_GROUP"
                echo "API App Name: $API_NAME"
                echo "Function App Name: $FUNCTION_NAME"
                
                # Deploy FastAPI app
                echo "Deploying FastAPI app to $API_NAME"
                az webapp deployment source config-zip --resource-group $RESOURCE_GROUP --name $API_NAME --src $(System.ArtifactsDirectory)/drop/app.zip
                
                # Deploy Azure Function
                echo "Deploying Azure Function to $FUNCTION_NAME"
                az functionapp deployment source config-zip --resource-group $RESOURCE_GROUP --name $FUNCTION_NAME --src $(System.ArtifactsDirectory)/drop/function.zip
                
                # Get function key and update the API app setting
                echo "Getting function key and updating API app settings"
                FUNCTION_KEY=$(az functionapp keys list --resource-group $RESOURCE_GROUP --name $FUNCTION_NAME --query "functionKeys.default" -o tsv)
                az webapp config appsettings set --resource-group $RESOURCE_GROUP --name $API_NAME --settings FUNCTION_KEY=$FUNCTION_KEY
            displayName: 'Deploy applications'